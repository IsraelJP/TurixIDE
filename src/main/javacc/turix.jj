
options {
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(Turix)
package com.turix.TurixCC;
import Semantico.*;

public class Turix {
    public static void main(String[] args) throws ParseException {
        System.out.println("Ingresa una expresión (ej: 10+20-5). Ctrl+D para terminar:");
        Turix parser = new Turix(System.in);
        parser.Start();
        System.out.println("✔ Expresión válida");
    }
    public Turix(SimpleCharStream stream) {
    this(new TurixTokenManager(stream));
}

}
PARSER_END(Turix)

SKIP : {
  " " | "\t" | "\r" | "\n"
}

TOKEN : {
    
    < NUM:( (["0"-"9"])+ )>
    |< NUM_DEC:(( ["0"-"9"] )+ ( "." (["0"-"9"])+ ) )>
    |<STRING_LITERAL : 
        // String multilínea 
        "\"\"\"" (~["\""] | "\"" | "\"\"")* "\"\"\""
      |
        // String normal de una línea
        "\"" ( "\\" | ~["\"","\\","\n","\r"] )* "\""
     >
     
    //OPERADORES MATEMATICOS
    | < MAS: "+" >
    | < MENOS: "-" >    
    | < MULTIPLICACION: "*" > 
    | < DIVISION: "/" > 
    | < MODULO: "%" > 
    | <DOUBLE: "Double">
    | <IGUAL: "=">
    | <SQRT: "sqrt">  
    | <POW: "pow">     
    | <COS: "cos">     
    | <SIN: "sin">     
    | <LOG: "log"> 

    //TIPOS DE DATO
    | <INT: "Int">
    | <FLOAT: "Float">
    | <STRING: "String">
    | <BOOL: "Bool">
    | <CHARACTER: "Character">
   


    //OPERADORES LOGICOS
    | <AND: "&&">
    | <NOT: "!">
    | <OR: "||">
    
    //OPERADORES DE REALCION
    | < REL_OP : "==" | "!=" | ">=" | "<=" | ">" | "<" >

    //Simbolos
    | <DOS_PUN: ":">
    |<FLECHA : "->">
    |<COMILLA : "\"">
    |<COMA : ",">
    

    // Palabras reservadas para declaraciones
    | <FUNC: "func">
    | <LET: "let">
    | <VAR: "var">
    | <TERMINATOR: "terminator">
    | <SEPARATOR: "separator">
    | <PRINT: "print">
    | <READLINE: "readLine">

    // Palabras reservadas para control de flujo
    | <BREAK: "break">
    | <CASE: "case">
    | <DEFAULT_KEYWORD: "default"> 
    | <REPEAT: "repeat">
    | <ELSE: "else">
    | <FOR: "for">
    | <IF: "if">
    | <IN: "in">
    | <RETURN: "return">
    | <SWITCH: "switch">
    | <WHERE: "where">
    | <WHILE: "while">
    
    //ABRIR Y CERRAR
    | <K_I: "{"> 
    | <K_F: "}">
    | <PAR_I: "(">
    | <PAR_F: ")">
    | <COR_I: "[">
    | <COR_F: "]">


    // Palabras reservadas para tipos y contexto
    
    | <FALSE: "false">
    | <TRUE: "true">

    //IDENTIFCADOR
    | < IDENT : "`" ( ["A"-"Z","a"-"z","0"-"9","_"] )+ "`"
    | ( ["A"-"Z","a"-"z","_"] ) ( ["A"-"Z","a"-"z","0"-"9","_"] )* >
    
    //ERRORES
    | < ERROR: (["0"-"9"])+ ("." (["0"-"9"])+){2,} >
    | < ERROROPERA:  "=!" | "=>" | "=<" >
    |< ERROR_IDENT :
    (["A"-"Z","a"-"z","_"])(["A"-"Z","a"-"z","0"-"9","_"])*
    (~["A"-"Z","a"-"z","0"-"9","_"," ","\t","\r","\n",
      "!","\"","%","(",")","*","+",",","-","/",":",
      "=","[","]","{","}","&","|","?",">","<"])
    (["A"-"Z","a"-"z","0"-"9","_"])* |
    
    // Solo caracteres inválidos aislados
    (~["A"-"Z","a"-"z","_"," ","\t","\r","\n",
      "!","\"","%","(",")","*","+",",","-","/",":",
      "=","[","]","{","}","&","|","?",">","<","0"-"9"])+
>
     
    }

//CUERPO DEL PROGRAMA 
    void Start() :
    {
        TokenAsignaciones.SetTables();
    }
    {
        ListaSentencias() <EOF>
    }

    void ListaSentencias() :
    {}
    {
        ( Sentencia() )*
    }

    void Sentencia() :
    {}
    {
         DeclaracionVar()
       | DeclaracionLet()
       | DeclaracionIF()
       | Func()
       | RetornoSentencia()
       | Imprimir()
       | SentenciaRepeat()
       | LOOKAHEAD(2) LlamadoFunc()
       | Asignacion()
       | Switch()
       | SentenciaWhile()
       | Exp(null)

    }


//Declaraciones
    //IF
    void DeclaracionIF() :
    {}
    {
        <IF> Condicion() <K_I> ListaSentencias() <K_F> (LOOKAHEAD(2) DecElse()| LOOKAHEAD(2) ElseIf())?
    }

    void DecElse() :
    {}
    {
        <ELSE> <K_I> ListaSentencias() <K_F>
    }
    void ElseIf():
    {}
    {
         <ELSE> <IF> Condicion() <K_I> ListaSentencias() <K_F> (LOOKAHEAD(2) DecElse()| LOOKAHEAD(2) ElseIf())?
    }

    //SWITCH
    void Switch():
    {}
    {
        <SWITCH> Exp(null) <K_I> (Case())* (DefaultCase())? <K_F>
    }
    void Case():
    {}
    {
        <CASE> Exp(null) <DOS_PUN> ListaSentencias() 
    }

    void DefaultCase():
    {} 
    {
        <DEFAULT_KEYWORD> <DOS_PUN> ListaSentencias()
    }

    //REPEAT
    void SentenciaRepeat():
    {}
    {
        <REPEAT> <K_I> ListaSentencias() <K_F> <WHILE> Condicion() 
    }
    
    //WHILE
    void SentenciaWhile() :
    {}
    {
        <WHILE> Condicion() <K_I> ListaSentencias() <K_F>
    }



    //VAR 
    void DeclaracionVar() :
    { Token id; Token tipo=null; Token exp=null;}
    {
        <VAR> id=<IDENT> ( <DOS_PUN> tipo=Tipo() )? ( <IGUAL> exp=Exp(id) )?
        {
            TokenAsignaciones.InsertarSimbolo(id, tipo != null ? tipo.kind : 20, exp);
        }
    }

    
    //LET
    void DeclaracionLet() :
    {}
    {
        <LET> <IDENT> ( <DOS_PUN> Tipo() )? ( <IGUAL> Exp(null) )?
    }
    void ListaLet():
    {}
    {
    DeclaracionLet() (<COMA> DeclaracionLet())*
    }

    //ASIGNACION 

    void Asignacion():
    { Token izq; Token der; }
    {
        izq=<IDENT> <IGUAL> der=Exp(null)
        {
            TokenAsignaciones.checkAsing(izq, der);
        }
    }




//CONDICIONAL
    void Condicion() :
    {}
    {
       ( Exp(null) (<REL_OP> Exp(null) ((<AND> | <OR> | <NOT>)  (CondicionAnidada()|Exp(null)) (<REL_OP> Exp(null))?)* )? ) | ListaLet()
    }

    void CondicionAnidada(): 
    {}
    {
    <PAR_I> Condicion() <PAR_F>
    }


//Tipos de DATO
    Token Tipo() :
{
    Token t = null;
}
{
      t=<INT>      { return t; }
    | t=<FLOAT>    { return t; }
    | t=<STRING>   { return t; }
    | t=<BOOL>     { return t; }
    | t=<DOUBLE>   { return t; }
}


//OPERADORES

    void Operadores():
    {}
    {
    <MAS> | <MENOS> | <MULTIPLICACION> | <DIVISION> | <MODULO> 
    }



//FUNCIONES

    void funcionesDefinidas():
    {}
    {
     <SQRT> | <POW> |<COS>| <SIN>| <LOG>| <READLINE> 
    }
    
    void Func() :
    {}
    {
        <FUNC> <IDENT> <PAR_I> (Parametros())? <PAR_F> (Retorno())? <K_I> ListaSentencias() <K_F>
    }

    //
    void LlamadoFunc():
    {}
    {
    
    (<IDENT> |funcionesDefinidas() |Tipo()) <PAR_I> (ListaExp())? <PAR_F>
    }

    void ParametroLlamadaFun():
    {Token izq; Token der; }
    {
    izq=<IDENT> <DOS_PUN> der=Exp(izq){
    TokenAsignaciones.checkAsing(izq, der);
    }
    }
    
    //RETURN
    void Retorno() :
    {}
    {
       <FLECHA> Tipo()
    }

    void RetornoSentencia():
    {}
    {
        <RETURN> Exp(null) 
    }
    
    //PRINT
    void Imprimir():
    {}
    {
        <PRINT> <PAR_I> ListaExpPrint()  <PAR_F>
    }

    void ListaExpPrint():
    {}
    {
        Exp(null) (<COMA> (Exp(null) | Opcion_Print()  ))*
    }

    void Opcion_Print():
    {}
    {
        (  <TERMINATOR> <DOS_PUN> Exp(null) ) |
        (  <SEPARATOR> <DOS_PUN> Exp(null) ) 

    }


//PARAMETROS
    void Parametros() :
    {}
    {
       Parametro() (<COMA> Parametro())*
    }

    void Parametro() :
    {Token id; Token tipo; }
    {
       id=<IDENT> <DOS_PUN> tipo=Tipo(){
       TokenAsignaciones.InsertarSimbolo(id, tipo != null ? tipo.kind : 20, null);
       }
    }


//TERMINOS Y EXPRESIONES
    void ListaExp():
    {}
    {
        Exp(null) (<COMA> Exp(null))*
    }
    
   Token Term() :
    { Token t = null; }
    {   

        t=<NUM> { return t; }
        | t=<NUM_DEC> { return t; }
        | LOOKAHEAD(2) LlamadoFunc() { return null; }
        |LOOKAHEAD(2) ParametroLlamadaFun(){ return null; }
        |t=<IDENT> { 
            String msg = TokenAsignaciones.checkVariable(t);
            if (!msg.equals(" ")) {
                erroresSem.addError(msg);
            }
            return t; 
        }
      
      
      | t=<TRUE> { return t; }
      | t=<FALSE> { return t; }
      | t=<STRING_LITERAL> { return t; }
      
    }



    //EXPRESIONES
    Token Exp(Token iden) :
    {
        Token t = null;
        Token temp = null;

    }
    {
        ( <MENOS> )?
        t=Term(){
           if(t.kind==60){
            iden=t;
           }
        }
        ( 
            (Operadores()) 
               (temp=Term()
                    {
                        if (iden != null) {
                            TokenAsignaciones.checkAsing(iden, temp);
                        }

                    }
                | <PAR_I> temp=Exp(null) <PAR_F>) 
        )*
        {
            return t;
        }
    }


