
options {
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(Turix)
package com.turix.TurixCC;

public class Turix {
    public static void main(String[] args) throws ParseException {
        System.out.println("Ingresa una expresión (ej: 10+20-5). Ctrl+D para terminar:");
        Turix parser = new Turix(System.in);
        parser.Start();
        System.out.println("✔ Expresión válida");
    }
    public Turix(SimpleCharStream stream) {
    this(new TurixTokenManager(stream));
}

}
PARSER_END(Turix)

SKIP : {
  " " | "\t" | "\r" | "\n"
}

TOKEN : {
     
    < NUM:( ["0"-"9"] )+ ( "." (["0"-"9"])+ )? >
    | < MAS: "+" >
    | < MENOS: "-" >    
    |< MULTIPLICACION: "*" > 
    | < DIVISION: "/" > 
    | < MODULO: "%" > 
    | <DOUBLE: "Double">
    | <INT: "Int">
    | <UINT: "UInt">
    | <FLOAT: "Float">
    | <STRING: "String">
    | <BOOL: "Bool">
    | <CHARACTER: "Character">
    | < LETTER: [ "A"-"Z", "a"-"z" ] >

    //Valores booleanos
    |<BOOLEANO_VAL: "true"|"false">

    //OPERADORES LOGICOS
    | <AND: "&&">
    | <NOT: "!">
    | <OR: "||">
    
    //OPERADORES DE REALCION
    | < REL_OP : "==" | "!=" | ">=" | "<=" | ">" | "<" >

    //DECLARACION VAR
    | <DOS_PUN: ":">


    // Palabras reservadas para declaraciones
    |<IGUAL: "=">
    | <CLASS: "class">
    | <DEINIT: "deinit">
    | <ENUM: "enum">
    | <EXTENSION: "extension">
    | <FUNC: "func">
    | <IMPORT: "import">
    | <INIT: "init">
    | <INOUT: "inout">
    | <INTERNAL: "internal">
    | <LET: "let">
    | <OPERATOR: "operator">
    | <PRIVATE: "private">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <STRUCT: "struct">
    | <SUBSCRIPT: "subscript">
    | <TYPEALIAS: "typealias">
    | <VAR: "var">

    // Palabras reservadas para control de flujo
    | <BREAK: "break">
    | <CASE: "case">
    | <CONTINUE: "continue">
    | <DEFAULT_KEYWORD: "default"> // Renombrado para evitar conflicto con estado léxico
    | <DO: "do">
    | <ELSE: "else">
    | <FALLTHROUGH: "fallthrough">
    | <FOR: "for">
    | <IF: "if">
    | <IN: "in">
    | <RETURN: "return">
    | <SWITCH: "switch">
    | <WHERE: "where">
    | <WHILE: "while">
    
    //ABRIR Y CERRAR
    | <K_I: "{"> 
    | <K_F: "}">
    | <PAR_I: "(">
    | <PAR_F: ")">
    | <COR_I: "[">
    | <COR_F: "]">


    // Palabras reservadas para tipos y contexto
    | <AS: "as">
    | <CATCH: "catch">
    | <FALSE: "false">
    | <IS: "is">
    | <NIL: "nil">
    | <RETHROWS: "rethrows">
    | <SUPER: "super">
    | <SELF: "self">
    | <SELF_CAP: "Self"> // Renombrado para evitar confusión
    | <THROW: "throw">
    | <THROWS: "throws">
    | <TRUE: "true">
    | <TRY: "try">

    // Palabras reservadas para modificadores y atributos
    | <ASSOCIATIVITY: "associativity">
    | <CONVENIENCE: "convenience">
    | <DYNAMIC: "dynamic">
    | <DIDSET: "didSet">
    | <FINAL: "final">
    | <GET: "get">
    | <INFIX: "infix">
    | <INDIRECT: "indirect">
    | <LAZY: "lazy">
    | <LEFT: "left">
    | <MUTATING: "mutating">
    | <NONE: "none">
    | <NONMUTATING: "nonmutating">
    | <OPTIONAL: "optional">
    | <OVERRIDE: "override">
    | <POSTFIX: "postfix">
    | <PRECEDENCE: "precedence">
    | <PREFIX: "prefix">
    | <PROTOCOL: "protocol">
    | <PROTOCOL_CAP: "Protocol"> // Diferenciamos "protocol" y "Protocol"
    | <REQUIRED: "required">
    | <RIGHT: "right">
    | <SET: "set">
    | <TYPE: "Type">
    | <UNOWNED: "unowned">
    | <WEAK: "weak">
    | <WILLSET: "willSet">

    // Funciones comunes
    | <PRINT: "print">

    |< IDENT : ( ["A"-"Z","a"-"z","_"] ) ( ["A"-"Z","a"-"z","0"-"9","_"] )* >
    
    //ERRORES
    | < ERROR: (["0"-"9"])+ ("." (["0"-"9"])+){2,} >
     | < ERROROPERA:  "=!" | "=>" | "=<" >
    }

void Start() :
{}
{
    ( Exp() | DeclaracionVar() | DeclaracionIF() ) <EOF>
}

void Sentencias() :
{}
{
     DeclaracionVar() 
    |DeclaracionIF() 
    |Exp() 
}

void ListaSentencias() :
{}
{
     (Sentencias())*
}



//Declaracion IF
void DeclaracionIF() :
{}
{
    <IF> <PAR_I> Condicion() <PAR_F> <K_I> (Sentencias())* <K_F> 
}

void Condicion() :
{}
{
    ( <NUM> | <IDENT> ) <REL_OP> ( <NUM> | <IDENT> )
}



void DeclaracionVar() :
{}
{
    <VAR> <IDENT> ( <DOS_PUN> Tipo() )? ( <IGUAL> Exp() )?
}

void Tipo() :
{}
{
    <INT> | <UINT> | <FLOAT> | <STRING> | <BOOL>
}

void Exp() :
{}
{
    Term() ( ( <MAS> | <MENOS> ) Term() )*
}

void Term() :
{}
{
    <NUM> | <IDENT> | <TRUE> | <FALSE>
}
