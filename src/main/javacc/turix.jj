
options {
  STATIC = false;
  UNICODE_INPUT = true;
}

PARSER_BEGIN(Turix)
package com.turix.TurixCC;

public class Turix {
    public static void main(String[] args) throws ParseException {
        System.out.println("Ingresa una expresión (ej: 10+20-5). Ctrl+D para terminar:");
        Turix parser = new Turix(System.in);
        parser.Start();
        System.out.println("✔ Expresión válida");
    }
    public Turix(SimpleCharStream stream) {
    this(new TurixTokenManager(stream));
}

}
PARSER_END(Turix)

SKIP : {
  " " | "\t" | "\r" | "\n"
}

TOKEN : {
     
    < NUM:( ["0"-"9"] )+ ( "." (["0"-"9"])+ )? >
    |<STRING_LITERAL : 
        // String multilínea 
        "\"\"\"" (~["\""] | "\"" | "\"\"")* "\"\"\""
      |
        // String normal de una línea
        "\"" ( "\\" | ~["\"","\\","\n","\r"] )* "\""
     >
    | < MAS: "+" >
    | < MENOS: "-" >    
    |< MULTIPLICACION: "*" > 
    | < DIVISION: "/" > 
    | < MODULO: "%" > 
    | <DOUBLE: "Double">
    | <INT: "Int">
    | <UINT: "UInt">
    | <FLOAT: "Float">
    | <STRING: "String">
    | <BOOL: "Bool">
    | <CHARACTER: "Character">
    | < LETTER: [ "A"-"Z", "a"-"z" ] >


    //OPERADORES LOGICOS
    | <AND: "&&">
    | <NOT: "!">
    | <OR: "||">
    
    //OPERADORES DE REALCION
    | < REL_OP : "==" | "!=" | ">=" | "<=" | ">" | "<" >

    //Simbolos
    | <DOS_PUN: ":">
    |<FLECHA : "->">
    |<COMILLA : "\"">
    |<COMA : ",">
    |<INTERROGACION : "??">


    // Palabras reservadas para declaraciones
    |<IGUAL: "=">
    | <CLASS: "class">
    | <DEINIT: "deinit">
    | <ENUM: "enum">
    | <EXTENSION: "extension">
    | <FUNC: "func">
    | <IMPORT: "import">
    | <INIT: "init">
    | <INOUT: "inout">
    | <INTERNAL: "internal">
    | <LET: "let">
    | <OPERATOR: "operator">
    | <PRIVATE: "private">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <STRUCT: "struct">
    | <SUBSCRIPT: "subscript">
    | <TYPEALIAS: "typealias">
    | <VAR: "var">
    | <TERMINATOR: "terminator">
    | <SEPARATOR: "separator">

    // Palabras reservadas para control de flujo
    | <BREAK: "break">
    | <CASE: "case">
    | <CONTINUE: "continue">
    | <DEFAULT_KEYWORD: "default"> // Renombrado para evitar conflicto con estado léxico
    | <DO: "do">
    | <ELSE: "else">
    | <FALLTHROUGH: "fallthrough">
    | <FOR: "for">
    | <IF: "if">
    | <IN: "in">
    | <RETURN: "return">
    | <SWITCH: "switch">
    | <WHERE: "where">
    | <WHILE: "while">
    
    //ABRIR Y CERRAR
    | <K_I: "{"> 
    | <K_F: "}">
    | <PAR_I: "(">
    | <PAR_F: ")">
    | <COR_I: "[">
    | <COR_F: "]">


    // Palabras reservadas para tipos y contexto
    | <AS: "as">
    | <CATCH: "catch">
    | <FALSE: "false">
    | <IS: "is">
    | <NIL: "nil">
    | <RETHROWS: "rethrows">
    | <SUPER: "super">
    | <SELF: "self">
    | <SELF_CAP: "Self"> // Renombrado para evitar confusión
    | <THROW: "throw">
    | <THROWS: "throws">
    | <TRUE: "true">
    | <TRY: "try">

    // Palabras reservadas para modificadores y atributos
    | <ASSOCIATIVITY: "associativity">
    | <CONVENIENCE: "convenience">
    | <DYNAMIC: "dynamic">
    | <DIDSET: "didSet">
    | <FINAL: "final">
    | <GET: "get">
    | <INFIX: "infix">
    | <INDIRECT: "indirect">
    | <LAZY: "lazy">
    | <LEFT: "left">
    | <MUTATING: "mutating">
    | <NONE: "none">
    | <NONMUTATING: "nonmutating">
    | <OPTIONAL: "optional">
    | <OVERRIDE: "override">
    | <POSTFIX: "postfix">
    | <PRECEDENCE: "precedence">
    | <PREFIX: "prefix">
    | <PROTOCOL: "protocol">
    | <PROTOCOL_CAP: "Protocol"> // Diferenciamos "protocol" y "Protocol"
    | <REQUIRED: "required">
    | <RIGHT: "right">
    | <SET: "set">
    | <TYPE: "Type">
    | <UNOWNED: "unowned">
    | <WEAK: "weak">
    | <WILLSET: "willSet">

    // Funciones comunes
    | <PRINT: "print">
    | <READLINE: "readLine">

    |< IDENT : ( ["A"-"Z","a"-"z","_"] ) ( ["A"-"Z","a"-"z","0"-"9","_"] )* >
    
    //ERRORES
    | < ERROR: (["0"-"9"])+ ("." (["0"-"9"])+){2,} >
     | < ERROROPERA:  "=!" | "=>" | "=<" >
    }

void Start() :
{}
{
    ListaSentencias() <EOF>
}

void ListaSentencias() :
{}
{
    ( Sentencia() )*
}

void Sentencia() :
{}
{
     DeclaracionVar()
   | DeclaracionLet()
   | DeclaracionIF()
   | Exp()
   | Func()
   | RetornoSentencia()
   | Imprimir()
}


//Declaracion IF
void DeclaracionIF() :
{}
{
    <IF> <PAR_I> Condicion() <PAR_F> <K_I> ListaSentencias() <K_F>
}

void Condicion() :
{}
{
    Exp() <REL_OP> Exp()
}

void DeclaracionVar() :
{}
{
    <VAR> <IDENT> ( <DOS_PUN> Tipo() )? ( <IGUAL> Exp() )?
}

void DeclaracionLet():
{}
{
 <LET> <IDENT> ( <DOS_PUN> Tipo() )? ( <IGUAL> Exp() ( <INTERROGACION> Exp() )? )?
}

void Tipo() :
{}
{
    <INT> | <UINT> | <FLOAT> | <STRING> | <BOOL> | <DOUBLE>
}

void Exp() :
{}
{
   (<MENOS>)? Term() ( ( <MAS> | <MENOS> ) Term() )*
}

void Term() :
{}
{
      <NUM> | <IDENT>  | <TRUE> | <FALSE> | <PAR_I> Exp() <PAR_F> | <STRING_LITERAL>
      |<READLINE> <PAR_I> <PAR_F> | Tipo() <PAR_I> Exp() <PAR_F>  
}

void Func() :
{}
{
    <FUNC> <IDENT> <PAR_I> (Parametros())? <PAR_F> (Retorno())? <K_I> ListaSentencias() <K_F>
}

void Parametros() :
{}
{
   Parametro() (<COMA> Parametro())*
}

void Parametro() :
{}
{
   <IDENT> <DOS_PUN> Tipo()
}

void Retorno() :
{}
{
   <FLECHA> Tipo()
}

void RetornoSentencia():
{}
{
    <RETURN> Exp() (<INTERROGACION> Exp())?
}

void Imprimir():
{}
{
    <PRINT> <PAR_I> ListaExpPrint()  <PAR_F>
}

void ListaExp():
{}
{
    Exp() (<COMA> Exp())*
}

void ListaExpPrint():
{}
{
    Exp() (<COMA> (Exp() | Opcion_Print()  ))*
}

void Opcion_Print():
{}
{
 (  <TERMINATOR> <DOS_PUN> Exp() ) |
(  <SEPARATOR> <DOS_PUN> Exp() ) 

}